<!-- backend/head.html -->
<style>
  :root{
    --title-pad-x: 72px;
    --logo-pad-left: 32px;
    --nav-pad-right: 32px;

    --edge-left:  calc(var(--title-pad-x) + var(--logo-pad-left));
    --edge-right: calc(var(--title-pad-x) + var(--nav-pad-right));

    --head-gap: 34px;

    --radius: 18px;
    --shadow-soft: 0 12px 34px rgba(0,0,0,.14);
  }

  .head-wrap{
    width:100%;
    padding-left:  var(--edge-left);
    padding-right: var(--edge-right);
    padding-top:   var(--head-gap);
    padding-bottom:var(--head-gap);
  }

  .hero{
    width:100%;
    height:52vh;
    min-height:360px;
    max-height:620px;
    border-radius: var(--radius);
    overflow:hidden;
    position:relative;
    background:#d9dde3;
    box-shadow: var(--shadow-soft);
  }
  .hero__bg{
    position:absolute; inset:0;
    background-size:cover;
    background-position:center;
    transform: scale(1.02);
    filter: saturate(.92) contrast(.95);
  }
  .hero__tint{
    position:absolute; inset:0;
    background: rgba(30, 60, 120, .18);
    mix-blend-mode: multiply;
  }
  .hero__dim{
    position:absolute; inset:0;
    background: rgba(0,0,0,.22);
  }

  /* Strip: exakt voll, kein Restbild */
  .items-strip{
    margin-top: var(--head-gap);

    height:25vh;
    min-height:170px;
    max-height:240px;

    border-radius: var(--radius);
    background:#fff;
    box-shadow: var(--shadow-soft);

    display:flex;
    align-items:center;

    /* WICHTIG: kein gap, kein „Rest“ */
    gap:0;
    overflow:hidden;
  }

  /* Kachelbreite wird per JS gesetzt (CSS Variable) */
  .item-thumb{
    flex:0 0 var(--tileW, 220px);
    height:100%;
    border-radius:0;
    overflow:hidden;
    background:#eef1f6;
    box-shadow:0 6px 18px rgba(0,0,0,.10);
  }
  .item-thumb img{
    width:100%;
    height:100%;
    object-fit:cover;
    display:block;
    border-radius:0;
  }

  @media (max-width:700px){
    :root{
      --title-pad-x: 40px;
      --logo-pad-left: 16px;
      --nav-pad-right: 16px;
      --head-gap: 26px;
    }
    .hero{ height:46vh; min-height:300px; }
  }

  @media (max-width:560px){
    :root{
      --title-pad-x: 22px;
      --logo-pad-left: 10px;
      --nav-pad-right: 10px;
      --head-gap: 22px;
    }
    .items-strip{ min-height:150px; max-height:210px; }
    .hero{ min-height:260px; }
  }
</style>

<section class="head-wrap" aria-label="Header-Bereich">
  <div class="hero">
    <div class="hero__bg" id="heroBg"></div>
    <div class="hero__tint"></div>
    <div class="hero__dim"></div>
  </div>

  <div class="items-strip" id="itemsStrip" aria-label="Zufällige Artikelbilder"></div>
</section>

<script>
(async function(){
  const BG_MANIFEST    = "image/hintergrund/manifest.json";
  const ITEMS_MANIFEST = "Items/manifest.json";

  const load = async (p) => {
    const r = await fetch(p, { cache: "no-store" });
    if(!r.ok) throw new Error(p + " -> " + r.status);
    return await r.json();
  };

  const pick = (a) => a[Math.floor(Math.random() * a.length)];

  function shuffleUnique(arr){
    // entfernen von Duplikaten (falls Manifest doppelte Pfade enthält)
    const uniq = Array.from(new Set(arr));
    // shuffle
    for(let i = uniq.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [uniq[i], uniq[j]] = [uniq[j], uniq[i]];
    }
    return uniq;
  }

  function renderStrip(allImages){
    const strip = document.getElementById("itemsStrip");
    if(!strip) return;

    const W = strip.clientWidth;

    // Ziel: Kacheln sollen ähnlich wie vorher wirken, aber immer exakt aufgehen:
    // min/max Kachelbreite
    const minTile = 170;
    const maxTile = 260;

    // Erst grob schätzen: wie viele Kacheln könnten rein?
    let n = Math.max(1, Math.floor(W / 220));

    // Dann Kachelbreite so wählen, dass n Kacheln exakt passen
    // und in min/max bleibt. Wenn nicht, n anpassen.
    function tileWFor(n){ return Math.floor(W / n); }

    // n erhöhen/verringern bis tileW im Bereich ist
    while(n > 1 && tileWFor(n) > maxTile) n++;
    while(n > 1 && tileWFor(n) < minTile) n--;

    // finale Breite (integer), passt exakt: n * tileW <= W (Rest wird durch floor vermieden)
    const tileW = tileWFor(n);

    // Rest (W - n*tileW) verteilen wir NICHT als gap (sonst Restbild),
    // sondern lassen ihn einfach „rechts“ im Container leer? -> Nein:
    // wir setzen strip so, dass n*tileW = W, indem wir n neu berechnen wenn nötig:
    const nExact = Math.max(1, Math.floor(W / tileW));
    const used = nExact * tileW;

    // Wenn 1–2px Rest bleibt (durch Rundung), kompensieren wir durch tileW+1 auf die ersten kacheln:
    const remainder = W - used;

    strip.style.setProperty("--tileW", tileW + "px");
    strip.innerHTML = "";

    const imgs = shuffleUnique(allImages).slice(0, nExact);

    imgs.forEach((src, idx) => {
      const d = document.createElement("div");
      d.className = "item-thumb";

      // Restpixel verteilen: erste `remainder` Kacheln bekommen +1px
      if(idx < remainder){
        d.style.flexBasis = (tileW + 1) + "px";
      }

      const img = document.createElement("img");
      img.loading = "lazy";
      img.alt = "";
      img.src = src;

      d.appendChild(img);
      strip.appendChild(d);
    });
  }

  // Hero
  try{
    const bg = await load(BG_MANIFEST);
    if(Array.isArray(bg) && bg.length){
      document.getElementById("heroBg").style.backgroundImage =
        "url('image/hintergrund/" + pick(bg) + "')";
    }
  }catch(e){}

  // Items
  let items = [];
  try{
    const raw = await load(ITEMS_MANIFEST);
    if(Array.isArray(raw)) items = raw;
  }catch(e){}

  if(items.length){
    // initial render
    renderStrip(items);

    // bei Resize neu berechnen (damit jedes Format sauber ist)
    let t;
    window.addEventListener("resize", () => {
      clearTimeout(t);
      t = setTimeout(() => renderStrip(items), 120);
    }, { passive:true });
  }
})();
</script>
